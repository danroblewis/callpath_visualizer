<!DOCTYPE html>
<html>
<head>
    <title>Call Path Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 32px;
        }
        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 14px;
        }
        svg {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: white;
        }
        .node rect {
            fill: rgba(52, 152, 219, 0.15);
            stroke: #2980b9;
            stroke-width: 2;
            rx: 8;
        }
        .node rect:hover {
            fill: rgba(41, 128, 185, 0.25);
        }
        .node text {
            pointer-events: none;
            font-size: 12px;
            font-weight: bold;
            fill: #2c3e50;
        }
        .method-text {
            font-size: 11px;
            fill: #34495e;
        }
        .link {
            stroke: #7f8c8d;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        .link:hover {
            stroke: #e74c3c;
            stroke-width: 3;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .legend {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .legend h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .legend-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            background: #3498db;
            margin-right: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Call Path Visualization</h1>
        <p class="subtitle">Runtime call traces from Domain-Driven Design project</p>
        
        <div id="graph"></div>
        
        <div class="legend">
            <h3>Legend</h3>
            <div class="legend-item">
                <div class="legend-color"></div>
                <span><strong>Blue boxes:</strong> Classes with their methods</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7f8c8d;"></div>
                <span><strong>Gray arrows:</strong> Method calls between classes</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span><strong>Red arrows:</strong> Hover over edge to highlight</span>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        const data = {"nodes": [{"id": "CreateOrderUseCase", "name": "CreateOrderUseCase", "methods": ["__init__", "execute"], "method_count": 2}, {"id": "InventoryService", "name": "InventoryService", "methods": ["__init__", "check_availability", "reserve_items"], "method_count": 3}, {"id": "Order", "name": "Order", "methods": ["__init__", "_recalculate_total", "add_item", "complete"], "method_count": 4}, {"id": "OrderItem", "name": "OrderItem", "methods": ["__init__"], "method_count": 1}, {"id": "OrderRepository", "name": "OrderRepository", "methods": ["__init__", "get_all", "save"], "method_count": 3}, {"id": "OrderService", "name": "OrderService", "methods": ["__init__", "_generate_order_id", "create_order", "process_order"], "method_count": 4}, {"id": "Product", "name": "Product", "methods": ["__init__", "is_available", "reduce_stock"], "method_count": 3}, {"id": "ProductRepository", "name": "ProductRepository", "methods": ["__init__", "save"], "method_count": 2}, {"id": "User", "name": "User", "methods": ["__init__"], "method_count": 1}, {"id": "UserRepository", "name": "UserRepository", "methods": ["__init__"], "method_count": 1}], "links": [{"source": "InventoryService", "target": "Product", "source_method": "check_availability", "target_method": "is_available"}, {"source": "CreateOrderUseCase", "target": "InventoryService", "source_method": "execute", "target_method": "check_availability"}, {"source": "OrderService", "target": "OrderRepository", "source_method": "_generate_order_id", "target_method": "get_all"}, {"source": "OrderService", "target": "InventoryService", "source_method": "process_order", "target_method": "check_availability"}, {"source": "OrderService", "target": "Order", "source_method": "create_order", "target_method": "__init__"}, {"source": "OrderService", "target": "Order", "source_method": "create_order", "target_method": "add_item"}, {"source": "OrderService", "target": "OrderRepository", "source_method": "process_order", "target_method": "save"}, {"source": "Order", "target": "OrderItem", "source_method": "add_item", "target_method": "__init__"}, {"source": "CreateOrderUseCase", "target": "OrderService", "source_method": "execute", "target_method": "process_order"}, {"source": "OrderService", "target": "OrderRepository", "source_method": "create_order", "target_method": "save"}, {"source": "InventoryService", "target": "Product", "source_method": "reserve_items", "target_method": "reduce_stock"}, {"source": "CreateOrderUseCase", "target": "OrderService", "source_method": "execute", "target_method": "create_order"}, {"source": "OrderService", "target": "InventoryService", "source_method": "process_order", "target_method": "reserve_items"}, {"source": "OrderService", "target": "Order", "source_method": "process_order", "target_method": "complete"}, {"source": "InventoryService", "target": "ProductRepository", "source_method": "reserve_items", "target_method": "save"}]};
        
        // Build method locations for connection calculations
        data.nodes.forEach(node => {
            // Calculate width based on longest method or class name
            const longestText = Math.max(
                ...node.methods.map(m => m.length),
                node.name.length
            );
            // Use reasonable font width approximation (about 7px per character for 12px font)
            node.width = Math.max(longestText * 7 + 30, node.name.length * 8 + 20);
            node.height = node.method_count * 18 + 50; // Tighter spacing
            
            // Pre-calculate method positions relative to node center
            node.methodPositions = {};
            node.methods.forEach((method, i) => {
                node.methodPositions[method] = {
                    x: 0,
                    y: -node.height / 2 + 35 + i * 18
                };
            });
        });
        
        const svg = d3.select("#graph")
            .append("svg")
            .attr("width", 1200)
            .attr("height", 800);
        
        const tooltip = d3.select("#tooltip");
        
        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                container.attr("transform", event.transform);
            });
        
        svg.call(zoom);
        
        // Create container group for pan/zoom
        const container = svg.append("g");
        
        // Add arrow marker
        container.append("defs").append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 5)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#7f8c8d");
        
        // Create simulation
        const simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).id(d => d.id).distance(300))
            .force("charge", d3.forceManyBody().strength(-1200))
            .force("center", d3.forceCenter(600, 400))
            .force("collision", d3.forceCollide().radius(d => Math.max(d.width / 2, d.height / 2) + 40));
        
        // Draw links - connecting methods within nodes
        const link = container.append("g")
            .selectAll("line")
            .data(data.links)
            .enter().append("line")
            .attr("class", "link")
            .on("mouseover", function(event, d) {
                d3.select(this).attr("class", "link hover");
                tooltip.style("display", "block")
                    .html(`<strong>${d.source.name}</strong>.${d.source_method}<br>â†’<br><strong>${d.target.name}</strong>.${d.target_method}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", function(d) {
                d3.select(this).attr("class", "link");
                tooltip.style("display", "none");
            });
        
        // Draw nodes
        const node = container.append("g")
            .selectAll("g")
            .data(data.nodes)
            .enter().append("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${d.x || 0},${d.y || 0})`);
        
        // Add rectangle background
        node.append("rect")
            .attr("width", d => d.width)
            .attr("height", d => d.height)
            .attr("x", d => -d.width / 2)
            .attr("y", d => -d.height / 2)
            .on("mouseover", function(event, d) {
                d3.select(this).attr("fill", "rgba(41, 128, 185, 0.25)");
            })
            .on("mouseout", function(event, d) {
                d3.select(this).attr("fill", "rgba(52, 152, 219, 0.15)");
            });
        
        // Add class name
        node.append("text")
            .attr("y", d => -d.height / 2 + 20)
            .text(d => d.name)
            .attr("text-anchor", "middle");
        
        // Add methods with IDs for connections
        node.append("g")
            .attr("class", "methods")
            .attr("transform", d => `translate(0,${-d.height / 2 + 30})`)
            .selectAll("text")
            .data(d => d.methods.map(m => ({method: m, node: d})))
            .enter().append("text")
            .attr("id", d => `method-${d.node.id}-${d.method.replace(/_/g, '-')}`)
            .attr("class", "method-text")
            .attr("y", (d, i) => i * 18 + 14)
            .text(d => d.method)
            .attr("text-anchor", "middle");
        
        // Update positions on simulation tick - with method connections
        simulation.on("tick", () => {
            link
                .attr("x1", d => {
                    const srcNode = typeof d.source === 'object' ? d.source : data.nodes.find(n => n.id === d.source);
                    const srcPos = srcNode.methodPositions[d.source_method];
                    return srcNode.x + srcPos.x;
                })
                .attr("y1", d => {
                    const srcNode = typeof d.source === 'object' ? d.source : data.nodes.find(n => n.id === d.source);
                    const srcPos = srcNode.methodPositions[d.source_method];
                    return srcNode.y + srcPos.y;
                })
                .attr("x2", d => {
                    const tgtNode = typeof d.target === 'object' ? d.target : data.nodes.find(n => n.id === d.target);
                    const tgtPos = tgtNode.methodPositions[d.target_method];
                    return tgtNode.x + tgtPos.x;
                })
                .attr("y2", d => {
                    const tgtNode = typeof d.target === 'object' ? d.target : data.nodes.find(n => n.id === d.target);
                    const tgtPos = tgtNode.methodPositions[d.target_method];
                    return tgtNode.y + tgtPos.y;
                });
            
            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });
        
        // Add drag behavior
        node.call(d3.drag()
            .on("start", function(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", function(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", function(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }));
    </script>
</body>
</html>
